import * as React from 'react'
import { useState, useEffect } from 'react'
import { JimuMapViewComponent, type JimuMapView } from 'jimu-arcgis'
import { type AllWidgetProps } from 'jimu-core'
import { loading } from 'jimu-ui'

const Widget: React.FC<AllWidgetProps<any>> = (props) => {
  const configData = props.manifest.config
  const [selectedFeatures, setSelectedFeatures] = useState<any[]>([])
  const [jimuMapView, setJimuMapView] = useState<JimuMapView | null>(null)
  const [iframeSrc, setIframeSrc] = useState<string | null>(null)
  const [startDate, setstartDate] = useState<string | null>(null)
  const [endDate, setendDate] = useState<string | null>(null)
  const useMapWidgetId = configData.widgetID
  const websiteURL = configData.webURL
  useEffect(() => {
    if (!jimuMapView) {
      console.log('MapView is not available!')
      return
    }

    const view = jimuMapView.view

    if (view.ready) {
      console.log('view is ready')
    } else {
      console.log('view is stil loading')
    }

    const iframe = document.getElementById('stormPage') as HTMLIFrameElement

    if (iframe) {
      iframe.addEventListener('load', () => {
        const iframeDocument = iframe.contentDocument || iframe.contentWindow?.document

        if (iframeDocument) {
          const GetDateBtnelem = iframeDocument.getElementById('btnMeterDetails')
          if (GetDateBtnelem) {
            GetDateBtnelem.addEventListener('click', GetselectedDatebtnClick)
          }
        }
      })
    }

    const GetselectedDatebtnClick = (event: MouseEvent) => {
      const sdate = document.getElementById('dateStart')
      setstartDate(startDate)
      const edate = document.getElementById('dateEnd')
      setendDate(endDate)
      console.log('Selected Start date:', sdate)
      console.log('Selected End date:', edate)
    }

    // Func to handle map click
    //   const handleMapClick = async (event: any) => {
    //     console.log('Map click detected at:', event.mapPoint)

    //     // Perform a hitTest on the map view
    //     const hitTestResponse = await view.hitTest(event)
    //     const features = hitTestResponse.results
    //       .filter((result) => layerIds.includes(result.graphic.layer.id)) // Filter by layer IDs
    //       .map((result) => result.graphic) // Extract features

    //     console.log('Selected features:', features)
    //     setSelectedFeatures(features)
    //   }

    //   // Listen for click events on the map view
    //   view.on('click', handleMapClick)

    //   // Cleanup event listener on unmount
    //   return () => {
    //     view.off('click', handleMapClick)
    //   }
    // }, [jimuMapView])

    // const handleSelectedFeatureChange = (isUpdating: any) => {
    //   if (!isUpdating) {
    //     view.allLayerViews.forEach((LyrView) => {
    //       if (LyrView.layer.type === 'feature' && LyrView.selectedFeatures ) {
    //         console.log('Selected feature attributes:', LyrView.selectedFeatures)
    //       }
    //     })
    //   }
    // }

    // to handle graphics changes
    // const handleGraphicsChange = () => {
    //   console.log('Graphics updated:', view.graphics.items)
    //   if (view.graphics.length > 0) {
    //     const feature = view.graphics.items[0] // Get first graphic
    //     const attributes = feature.attributes // Get attributes
    //     console.log('Selected feature attributes:', attributes)
    //     const urlWithFeatures = websiteURL + attributes.METER_NO
    //     setIframeSrc(urlWithFeatures)
    //     setSelectedFeatures([feature])
    //   } else {
    //     setSelectedFeatures([])
    //   }
    // }

    // to handle popup changes
    const handlePopupChange = () => {
      const popup = view.popup
      if (popup.visible && popup.selectedFeature) {
        const feature = popup.selectedFeature
        console.log('Selected feature from popup:', feature)
        const attributes = feature.attributes
        console.log('Selected feature attributes:', attributes)
        const urlWithFeatures = websiteURL + attributes.METER_NO
        setIframeSrc(urlWithFeatures)
        setSelectedFeatures([feature])
      } else {
        setSelectedFeatures([])
      }
    }

    //const watchVisibility = view.watch('popup.visible', handlePopupChange)
    const watchSelectedFeature = view.watch('popup.selectedFeature', handlePopupChange)
    // Watch for changes in graphics
    //const watchGraphics = view.watch('graphics', handleGraphicsChange)

    // Watch for changes in the view
    //const watchview = view.watch('updating', handleSelectedFeatureChange)

    return () => {
      if (iframe) {
        const iframeDocument = iframe.contentDocument
        if (iframeDocument) {
          const GetDateBtnelem = iframeDocument.getElementById('btnMeterDetails')
          if (GetDateBtnelem) {
            GetDateBtnelem.removeEventListener('click', GetselectedDatebtnClick)
          }
        }
        iframe.removeEventListener('load', () => {
          console.log('Cleaned up iFrame event.')
        })
      }
      //watchVisibility.remove()
      watchSelectedFeature.remove()
      //watchGraphics.remove()
      //watchview.remove()
    }
  }, [endDate, jimuMapView, startDate, websiteURL])

  return (
  <div className="h-100 w-100">

    <JimuMapViewComponent
      useMapWidgetId={useMapWidgetId}
      onActiveViewChange={(view) => {
        console.log('mapview initialized:', view)
        setJimuMapView(view)
      }}
    />
    {/* <button onClick={openWebsite} disabled={selectedFeatures.length === 0}>
      Open Website with {selectedFeatures.length} Selected Features
    </button> */}
    <div className="h-100 w-100">
      <iframe id="stormPage" src={iframeSrc} className="h-100 w-100 border-0" loading="lazy" style={{ border: '1px solid #ccc' }} title="Embedded Website" />
      </div>
  </div>
  )
}

export default Widget




import { React, useEffect, useState } from 'react';
import { DataSourceComponent, DataRecord, DataSource } from 'jimu-core';

const MyCustomWidget = () => {
  const [records, setRecords] = useState<DataRecord[]>([]);
  const [selectedRecord, setSelectedRecord] = useState<DataRecord | null>(null);
  const [dataSource, setDataSource] = useState<DataSource | null>(null);

  useEffect(() => {
    // Function to handle data updates
    const handleDataChange = (newRecords: DataRecord[]) => {
      console.log('Records Updated:', newRecords);
      setRecords(newRecords); // Store records in state
    };

    // Function to handle record selection from an external event
    const handleExternalClick = () => {
      if (dataSource) {
        const currentRecords = dataSource.getRecords();
        if (currentRecords.length > 0) {
          setSelectedRecord(currentRecords[0]); // Select first record
          console.log('External Click Triggered:', currentRecords[0].getData());
        }
      }
    };

    // Attach event listener for external click
    window.addEventListener('customRecordClick', handleExternalClick);

    return () => {
      window.removeEventListener('customRecordClick', handleExternalClick);
    };
  }, [dataSource]); // Runs whenever `dataSource` changes

  return (
    <div>
      <h3>Current Data from External Table Widget</h3>

      <DataSourceComponent
        useDataSource={{ dataSourceId: 'your-data-source-id' }} // Replace with actual ID
        widgetId="your-widget-id" // Replace with your widget's ID
        onDataSourceCreated={(ds) => setDataSource(ds)} // Store data source in state
        onDataSourceUpdated={(records) => setRecords(records)} // Update state when data changes
      />

      {/* Display records */}
      <ul>
        {records.map((record, index) => (
          <li key={index}>{JSON.stringify(record.getData())}</li>
        ))}
      </ul>

      {/* Show selected record */}
      {selectedRecord && (
        <div>
          <h4>Selected Record:</h4>
          <pre>{JSON.stringify(selectedRecord.getData(), null, 2)}</pre>
        </div>
      )}
    </div>
  );
};

export default MyCustomWidget;

