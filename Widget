
import { React, DataSourceComponent, DataSource, AllWidgetProps } from 'jimu-core';
import { Loading } from 'jimu-ui';

interface State {
  iframeUrl: string;
  isLoading: boolean;
  selectedFeatures: any[];
}

export default class AutoEmbedWidget extends DataSourceComponent<AllWidgetProps<unknown>, State> {
  state: State = {
    iframeUrl: null,
    isLoading: false,
    selectedFeatures: [],
  };

  // Handle data source creation
  onDataSourceCreated = (ds: DataSource) => {
    this.ds = ds;
    this.ds.onPropertyChange('selectedIds', () => this.handleSelectionChange());
  };

  // Handle selection changes
  handleSelectionChange = async () => {
    this.setState({ isLoading: true });

    try {
      const selectedIds = this.ds?.selectedIds || [];
      const features = await this.queryFeaturesByIds(selectedIds);
      const newUrl = this.generateUrl(features);
      this.setState({ iframeUrl: newUrl, isLoading: false, selectedFeatures: features });
    } catch (error) {
      console.error('Error handling selection change:', error);
      this.setState({ isLoading: false });
    }
  };

  // Query features by their IDs
  queryFeaturesByIds = async (ids: string[]) => {
    if (!ids.length) return [];

    const query = {
      where: `${this.ds.idField} IN (${ids.map(id => `'${id}'`).join(',')})`,
      outFields: ['*'],
      returnGeometry: false,
    };

    const result = await this.ds.query(query);
    return result.records;
  };

  // Generate URL based on selected features
  generateUrl = (features: any[]): string => {
    if (!features.length) return this.props.config.defaultUrl || null;

    const attributes = features[0].getData(); // Use the first selected feature
    const baseUrl = this.props.config.urlTemplate;

    // Replace placeholders in the URL template with feature attributes
    return Object.entries(attributes).reduce((url, [key, value]) => {
      return url.replace(new RegExp(`{${key}}`, 'g'), encodeURIComponent(value as string));
    }, baseUrl);
  };

  // Validate URL for security
  isValidUrl = (url: string): boolean => {
    try {
      const parsed = new URL(url);
      return this.props.config.allowedDomains.includes(parsed.hostname);
    } catch {
      return false;
    }
  };

  render() {
    const { iframeUrl, isLoading, selectedFeatures } = this.state;
    const validUrl = iframeUrl && this.isValidUrl(iframeUrl);

    return (
      <div className="h-100 w-100 p-2">
        {isLoading && <Loading />}

        {validUrl ? (
          <iframe
            src={iframeUrl}
            className="h-100 w-100 border-0"
            loading="lazy"
            title="Dynamic Embedded Content"
          />
        ) : (
          <div className="text-warning">
            {iframeUrl ? "Invalid or blocked URL" : "Select a feature to load content"}
          </div>
        )}
      </div>
    );
  }
}



import { React, useEffect } from "react";
import { AllWidgetProps } from "jimu-core";

const Widget: React.FC<AllWidgetProps<any>> = (props) => {
  
  // Function to handle iframe message
  const handleIframeMessage = (event: MessageEvent) => {
    // Ensure the message comes from a trusted source
    if (event.origin !== "https://www.example.com") {
      return;
    }

    if (event.data === "Iframe clicked") {
      console.log("âœ… The iframe was clicked!");
    }
  };

  useEffect(() => {
    window.addEventListener("message", handleIframeMessage);

    return () => {
      window.removeEventListener("message", handleIframeMessage);
    };
  }, []);

  return (
    <div>
      <h3>Embedded iFrame</h3>
      <iframe
        src="https://www.example.com" // Replace with your iframe source
        width="600"
        height="400"
        style={{ border: "1px solid black" }}
      ></iframe>
    </div>
  );
};

export default Widget;

