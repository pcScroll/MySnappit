
import { React, DataSourceManager, DataSource, AllWidgetProps } from 'jimu-core';
import { Loading } from 'jimu-ui';

interface State {
  iframeUrl: string;
  isLoading: boolean;
  selectedFeatures: any[];
  ds?: DataSource;
}

export default class AutoEmbedWidget extends React.Component<AllWidgetProps<unknown>, State> {
  state: State = {
    iframeUrl: null,
    isLoading: false,
    selectedFeatures: [],
  };

  componentDidMount() {
    this.initializeDataSource();
  }

  componentWillUnmount() {
    this.removeSelectionListener();
  }

  // Initialize DataSource
  initializeDataSource = () => {
    const dsId = this.props.useDataSources?.[0]?.dataSourceId;
    if (!dsId) return;

    const ds = DataSourceManager.getInstance().getDataSource(dsId);
    if (ds) {
      this.setState({ ds });
      ds.onPropertyChange('selectedIds', this.handleSelectionChange);
    }
  };

  // Remove selection listener
  removeSelectionListener = () => {
    const { ds } = this.state;
    if (ds) {
      ds.offPropertyChange('selectedIds', this.handleSelectionChange);
    }
  };

  // Handle selection changes
  handleSelectionChange = async () => {
    this.setState({ isLoading: true });

    try {
      const { ds } = this.state;
      if (!ds) return;

      const selectedIds = ds.selectedIds || [];
      const features = await this.queryFeaturesByIds(selectedIds);
      const newUrl = this.generateUrl(features);

      this.setState({ iframeUrl: newUrl, isLoading: false, selectedFeatures: features });
    } catch (error) {
      console.error('Error handling selection change:', error);
      this.setState({ isLoading: false });
    }
  };

  // Query features by their IDs
  queryFeaturesByIds = async (ids: string[]) => {
    const { ds } = this.state;
    if (!ds || !ids.length) return [];

    const query = {
      where: `${ds.idField} IN (${ids.map(id => `'${id}'`).join(',')})`,
      outFields: ['*'],
      returnGeometry: false,
    };

    const result = await ds.query(query);
    return result.records;
  };

  // Generate URL based on selected features
  generateUrl = (features: any[]): string => {
    if (!features.length) return this.props.config.defaultUrl || null;

    const attributes = features[0].getData(); // Use the first selected feature
    const baseUrl = this.props.config.urlTemplate;

    // Replace placeholders in the URL template with feature attributes
    return Object.entries(attributes).reduce((url, [key, value]) => {
      return url.replace(new RegExp(`{${key}}`, 'g'), encodeURIComponent(value as string));
    }, baseUrl);
  };

  // Validate URL for security
  isValidUrl = (url: string): boolean => {
    try {
      const parsed = new URL(url);
      return this.props.config.allowedDomains.includes(parsed.hostname);
    } catch {
      return false;
    }
  };

  render() {
    const { iframeUrl, isLoading } = this.state;
    const validUrl = iframeUrl && this.isValidUrl(iframeUrl);

    return (
      <div className="h-100 w-100 p-2">
        {isLoading && <Loading />}

        {validUrl ? (
          <iframe
            src={iframeUrl}
            className="h-100 w-100 border-0"
            loading="lazy"
            title="Dynamic Embedded Content"
          />
        ) : (
          <div className="text-warning">
            {iframeUrl ? "Invalid or blocked URL" : "Select a feature to load content"}
          </div>
        )}
      </div>
    );
  }
}
