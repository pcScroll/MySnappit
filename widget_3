
Here's an updated approach for ArcGIS Experience Builder 1.16.0 using the `DataSourceManager` instead of `queryWidgetIds`:

```tsx
import * as React from 'react';
import { AllWidgetProps, DataSource, DataSourceManager, FeatureDataRecord, IMDataSourceInfo } from 'jimu-core';
import { TextInput } from 'jimu-ui';

interface State {
  selectedFeatures: FeatureDataRecord[];
}

export default class FeatureSelectionListener extends React.PureComponent<AllWidgetProps<unknown>, State> {
  state: State = {
    selectedFeatures: []
  };

  dataSources: { [dsId: string]: DataSource } = {};

  componentDidMount() {
    // Listen for all existing data sources
    const dsManager = DataSourceManager.getInstance();
    const allDataSources = dsManager.getDataSources();
    
    // Track existing data sources
    Object.keys(allDataSources).forEach(dsId => {
      this.handleDataSourceCreated(dsId);
    });

    // Listen for new data source creation
    dsManager.on('dataSourceCreated', this.handleDataSourceCreated);
    dsManager.on('dataSourceDestroyed', this.handleDataSourceDestroyed);
  }

  componentWillUnmount() {
    const dsManager = DataSourceManager.getInstance();
    dsManager.off('dataSourceCreated', this.handleDataSourceCreated);
    dsManager.off('dataSourceDestroyed', this.handleDataSourceDestroyed);
  }

  handleDataSourceCreated = (dsId: string) => {
    const dsManager = DataSourceManager.getInstance();
    const dataSource = dsManager.getDataSource(dsId);
    
    if (dataSource && !this.dataSources[dsId]) {
      this.dataSources[dsId] = dataSource;
      dataSource.onSelectionChange(() => this.handleSelectionChange(dsId));
    }
  };

  handleDataSourceDestroyed = (dsId: string) => {
    if (this.dataSources[dsId]) {
      delete this.dataSources[dsId];
    }
  };

  handleSelectionChange = (dsId: string) => {
    const dataSource = DataSourceManager.getInstance().getDataSource(dsId);
    const selectedFeatures = dataSource?.getSelectedRecords() || [];
    this.setState({ selectedFeatures });
  };

  render() {
    return (
      <div className="p-2">
        <h4>Selected Features:</h4>
        {this.state.selectedFeatures.map((feature, index) => (
          <div key={index} className="mb-2 p-2 border">
            <TextInput
              readOnly
              value={JSON.stringify(feature.attributes, null, 2)}
              style={{ width: '100%', minHeight: '100px' }}
            />
            {feature.feature.geometry && 
              <div className="mt-2">
                <p>Geometry:</p>
                <pre style={{ fontSize: '12px' }}>
                  {JSON.stringify(feature.feature.geometry, null, 2)}
                </pre>
              </div>
            }
          </div>
        ))}
      </div>
    );
  }
}
```

Key changes for 1.16.0 compatibility:

1. **DataSourceManager Usage**:
- Uses `DataSourceManager.getInstance()` instead of widget context
- Listens to `dataSourceCreated` and `dataSourceDestroyed` events

2. **Selection Handling**:
- Attaches to each data source's `onSelectionChange` event
- Automatically works with both map features and table rows
- Handles geometry display for spatial selections

3. **Lifecycle Management**:
- Proper cleanup of event listeners
- Tracks active data sources in component state

4. **Universal Compatibility**:
- Works with any widget that uses data sources (Map, Table, List, etc.)
- Automatically detects new data sources added to the experience

**How to use:**
1. Add this widget to your experience
2. Configure other widgets (Map/Table) with selectable data sources
3. Select features in either map or table
4. Selected features will appear in this widget with attributes and geometry

**Features:**
- Real-time updates for both map and table selections
- Displays attribute information for all selections
- Shows geometry data when available (map selections)
- Automatic cleanup of event listeners
- Works with multiple simultaneous selections

**Note:** This implementation will show selections from *all* data sources in the experience. If you want to filter specific data sources, you can add checks in the `handleSelectionChange` method using the `dsId` parameter.
