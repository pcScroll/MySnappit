
import { React, AllWidgetProps, DataSourceComponent } from 'jimu-core';
import { Loading } from 'jimu-ui';
import { DataSource } from 'jimu-core';

interface State {
  iframeUrl: string;
  isLoading: boolean;
  selectedFeatures: any[];
}

export default class AutoEmbedWidget extends DataSourceComponent<AllWidgetProps<any>, State> {
  state: State = {
    iframeUrl: this.props.config?.defaultUrl || '',
    isLoading: false,
    selectedFeatures: [],
  };

  // Called when the data source is created
  onDataSourceCreated = (ds: DataSource) => {
    // Add the listener for selection change from the data source
    ds.onSelectionChange = this.handleSelectionChange;
  };

  componentDidMount() {
    this.initializeDataSources();
  }

  // Initialize data sources dynamically
  initializeDataSources = () => {
    const dataSources = this.props.useDataSources;
    if (!dataSources || !dataSources.length) {
      console.warn('No data sources found.');
      return;
    }

    // Initialize data sources and set listeners
    dataSources.forEach((ds) => {
      if (ds.dataSourceId) {
        this.onDataSourceCreated(ds);
      }
    });
  };

  // Handle selection change event
  handleSelectionChange = async () => {
    this.setState({ isLoading: true });

    try {
      // Collect all selected feature IDs
      const selectedIds = this.getSelectedFeatureIds();
      if (selectedIds.length === 0) {
        this.setState({ iframeUrl: this.props.config?.defaultUrl || '', isLoading: false });
        return;
      }

      // Query features based on selected IDs
      const features = await this.queryFeaturesByIds(selectedIds);
      const newUrl = this.generateUrl(features);
      this.setState({ iframeUrl: newUrl, isLoading: false, selectedFeatures: features });
    } catch (error) {
      console.error('Error handling selection change:', error);
      this.setState({ isLoading: false });
    }
  };

  // Get all selected feature IDs from the data sources
  getSelectedFeatureIds = () => {
    const selectedIds: string[] = [];
    const dataSources = this.props.useDataSources;

    dataSources.forEach((ds) => {
      const ids = ds.selectedIds || [];
      selectedIds.push(...ids);
    });

    return selectedIds;
  };

  // Query features based on their IDs
  queryFeaturesByIds = async (ids: string[]) => {
    const allFeatures: any[] = [];
    for (const ds of this.props.useDataSources) {
      const query = {
        where: `${ds.idField} IN (${ids.map(id => `'${id}'`).join(',')})`,
        outFields: ['*'],
        returnGeometry: false,
      };

      const result = await ds.query(query);
      allFeatures.push(...result.records);
    }
    return allFeatures;
  };

  // Generate URL based on selected features
  generateUrl = (features: any[]): string => {
    if (!features.length) return this.props.config?.defaultUrl || '';

    const attributes = features[0].getData(); // Use the first selected feature
    const baseUrl = this.props.config?.urlTemplate || this.props.config?.defaultUrl || '';

    return Object.entries(attributes).reduce((url, [key, value]) => {
      return url.replace(new RegExp(`{${key}}`, 'g'), encodeURIComponent(value as string));
    }, baseUrl);
  };

  render() {
    const { iframeUrl, isLoading } = this.state;

    return (
      <div className="h-100 w-100 p-2">
        {isLoading && <Loading />}
        <iframe
          src={iframeUrl}
          className="h-100 w-100 border-0"
          loading="lazy"
          title="Embedded Website"
        />
      </div>
    );
  }
}
